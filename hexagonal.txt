1. cmd/ (Command)

Purpose: Contains the main entry points for your application(s). In a hexagonal architecture, you might have different "drivers" or applications interacting with your core domain.
Subfolders (Example):
api/: Houses the entry point for your primary API application (e.g., using HTTP).
worker/: (Optional) If you have background tasks or worker processes, this would contain their entry point.
main.go Files: Each subfolder (api/, worker/) will contain a main.go file. This file is responsible for:
Wiring up dependencies: Initializing the application container, infrastructure components, and connecting them to the domain.
Starting the application: Launching the API server (HTTP listener), starting worker processes, etc.
Hexagonal Role: This is the outermost layer, representing the "drivers" or ways to interact with the core application. It's framework-specific (e.g., net/http for API, a specific worker library).
2. config/ (Configuration)

Purpose: Stores configuration files for your application. Separating configuration makes it easier to deploy to different environments (development, staging, production) without recompiling.
Files (Example):
config.yaml, config.json, config.toml: Configuration files in different formats. You might choose one or use a library that supports multiple formats.
Hexagonal Role: This is also part of the outer layer, providing external configuration to the application. The core domain should ideally be configurable through interfaces, and the config package provides the concrete values.
3. domain/ (Domain)

Purpose: This is the heart of your application. It contains the core business logic, rules, entities, and use cases, completely independent of any external frameworks, libraries, or infrastructure. It should be pure Go code, focusing on what your application does, not how it's done in terms of technology.
Subfolders:
entities/:
Purpose: Defines the data structures (entities) that represent your domain concepts. These are plain Go structs with data and potentially domain logic (though ideally minimal).
Example: user.go might define the User struct with fields like ID, Name, Email, and methods related to user validation or behavior.
ports/:
Purpose: Defines interfaces that act as gateways between the domain and the outside world. Ports are abstract contracts that the domain depends on for input and output. They are technology-agnostic.
input/ (Inbound Ports / Primary Ports / Driving Ports):
Purpose: Interfaces that define how external actors (like APIs, CLIs, or other applications) can interact with and drive the domain. These are often use cases or services exposed by the domain.
Example: user_service.go might define an interface UserService with methods like CreateUser, GetUserByID, UpdateUser, DeleteUser.
output/ (Outbound Ports / Secondary Ports / Driven Ports):
Purpose: Interfaces that define how the domain needs to interact with external systems (like databases, message queues, external APIs). These are abstractions for things the domain needs to drive or depend on.
Example: user_repository.go might define an interface UserRepository with methods like Save, FindByID, FindByEmail, Delete.
service.go (Optional): You can have a service.go inside ports if you have common service-related interfaces that are used in both input and output ports or if you want to group general service contracts.
usecases/:
Purpose: Contains the actual business logic and application use cases. These are implementations of the input ports defined in domain/ports/input/. Use cases orchestrate entities and interact with output ports to fulfill business requirements.
Example: user_management.go might contain structs that implement the UserService interface (from domain/ports/input/user_service.go). A use case implementation would:
Validate input.
Interact with domain entities.
Use UserRepository (from domain/ports/output/user_repository.go) to persist or retrieve data.
Apply business rules and logic.
Return results.
Hexagonal Role: This is the core or inside of the hexagon. It's technology-agnostic and focuses solely on business logic.
4. infrastructure/ (Infrastructure)

Purpose: Contains the adapters that implement the output ports (defined in domain/ports/output/) and handle the input ports (defined in domain/ports/input/) in terms of concrete technologies. This layer bridges the gap between the technology-agnostic domain and the technology-specific outside world.
Subfolders:
api/:
Purpose: Implements the input ports (like UserService) as concrete APIs (e.g., RESTful HTTP endpoints, gRPC services). These are the "driving adapters" that drive the domain based on external requests.
Example: user_handler.go might contain HTTP handlers that:
Receive HTTP requests.
Translate HTTP requests into calls to the UserService interface (from domain/ports/input/).
Translate the results from the UserService back into HTTP responses.
database/:
Purpose: Implements the output ports (like UserRepository) using specific database technologies (e.g., PostgreSQL, MySQL, MongoDB). These are "driven adapters" because they are driven by the domain when the domain needs to interact with a database.
Example: user_repository_impl.go might implement the UserRepository interface (from domain/ports/output/user_repository.go) using PostgreSQL. It would contain database-specific code to interact with PostgreSQL, execute queries, and map database records to domain entities.
logger/:
Purpose: Provides a concrete implementation of a logging interface (if you have one defined in your domain or shared across layers).
messagequeue/:
Purpose: (Optional) If your application uses message queues, this would contain adapters to interact with specific message queue systems (e.g., Kafka, RabbitMQ). These would likely implement output ports if the domain publishes events or input ports if the domain consumes messages.
Hexagonal Role: This is part of the outer layer, consisting of "adapters" that translate between the domain's ports and specific technologies. Adapters are technology-dependent.
5. internal/ (Internal)

Purpose: Contains packages that are for internal use within your application only. Go's internal package visibility mechanism ensures that these packages cannot be imported by code outside of your project.
Subfolders:
app/:
Purpose: Application setup and initialization logic. This might include bootstrapping the application, dependency injection setup, and overall application lifecycle management.
Example: app.go might contain functions to:
Load configuration from config/.
Initialize infrastructure components (database connections, message queue clients, loggers).
Instantiate use cases in the domain/ layer.
Wire up adapters in infrastructure/ to the use cases.
Register API handlers.
container/:
Purpose: (Optional) If you are using a dependency injection (DI) container, this folder could house the container setup and configuration. However, in Go, you might also choose to use manual dependency injection (wiring up dependencies in internal/app/).
Hexagonal Role: This layer is mainly concerned with application assembly and internal organization, supporting the hexagonal architecture but not strictly part of the core hexagonal concepts themselves. It helps in managing dependencies and application lifecycle.
6. pkg/ (Packages)

Purpose: Contains reusable packages that are independent of your specific application's business domain but might be useful across different parts of your application or even in other Go projects. These are utility packages, helper functions, and generic components.
Subfolders:
errors/:
Purpose: Defines custom error types that can be used throughout the application. These are often more specific and informative than generic Go errors.
Hexagonal Role: This is a general utility layer. While not directly related to hexagonal architecture's core principles, it's a common and good practice to organize reusable code in a pkg/ directory in Go projects.
7. go.mod and go.sum

Purpose: Go modules files. go.mod tracks module dependencies, and go.sum ensures reproducible builds by storing checksums of dependencies.
Key Principles Illustrated by this Structure:

Separation of Concerns: Clear separation between business logic (domain/) and infrastructure (infrastructure/). Changes in infrastructure (e.g., switching databases) should ideally not require changes in the domain.
Dependency Inversion Principle: The domain/ layer depends on abstractions (ports - interfaces in domain/ports/), not on concrete implementations. Concrete implementations (adapters) reside in the infrastructure/ layer and implement the interfaces. This makes the domain testable and independent.
Testability: The domain layer, being framework-agnostic, is easily unit-testable. Adapters in the infrastructure/ layer can be tested with integration tests or mocked/stubbed for unit tests of the handlers/controllers in the infrastructure/api/ layer.
Maintainability and Flexibility: The hexagonal architecture makes the application more maintainable and adaptable to changes. You can switch infrastructure technologies or add new ways to interact with the application without significantly impacting the core business logic.